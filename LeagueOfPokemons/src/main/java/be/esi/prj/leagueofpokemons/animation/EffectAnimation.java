package be.esi.prj.leagueofpokemons.animation;

import be.esi.prj.leagueofpokemons.model.core.Effect;
import javafx.animation.*;
import javafx.scene.Node;
import javafx.scene.effect.BlurType;
import javafx.scene.effect.DropShadow;
import javafx.scene.effect.GaussianBlur;
import javafx.scene.image.ImageView;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import javafx.util.Duration;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

/**
 * Utility class that handles the visual representation of various Pokémon battle effects
 * using JavaFX animations. Each supported effect type—such as Burn, Dodge, Drain,
 * Paralyze, and Critical Hit—is associated with a custom particle or glow animation
 * to visually enhance the effect during gameplay.
 * <p>
 * This class has been generated by AI, and some adjustments have been made.
 */
public class EffectAnimation {

    private static final Random RANDOM = new Random();
    private static final double ANIMATION_DURATION = 2.5; // seconds


    private EffectAnimation() {}

    /**
     * Plays the appropriate animation based on the provided effect type.
     *
     * @param pokemonImage The ImageView of the Pokémon to animate.
     * @param parentPane   The parent pane to which particle effects and other visuals will be added.
     * @param effectType   The type of effect to animate (e.g., BURN, DODGE, etc.).
     */
    public static void playEffectAnimation(ImageView pokemonImage, Pane parentPane, Effect.EffectType effectType) {
        switch (effectType) {
            case BURN -> playBurnAnimation(pokemonImage, parentPane);
            case DODGE -> playDodgeAnimation(pokemonImage, parentPane);
            case DRAIN -> playDrainAnimation(pokemonImage, parentPane);
            case PARALYZE -> playParalyzeAnimation(pokemonImage, parentPane);
            case CRIT -> playCritAnimation(pokemonImage, parentPane);
        }
    }

    /**
     * Plays a blue particle animation around the Pokémon to indicate a DODGE effect.
     * Includes a circular particle movement and a side-step animation on the Pokémon.
     *
     * @param pokemonImage The ImageView of the dodging Pokémon.
     * @param parentPane   The parent pane to render the particles on.
     */
    private static void playDodgeAnimation(ImageView pokemonImage, Pane parentPane) {
        List<Circle> particles = createParticles(40, Color.DODGERBLUE, pokemonImage);

        parentPane.getChildren().addAll(particles);

        ParallelTransition parallelTransition = new ParallelTransition();

        // Calculate center point of the pokemon image for the circular animation
        double centerX = pokemonImage.getLayoutX() + pokemonImage.getFitWidth() / 2;
        double centerY = pokemonImage.getLayoutY() + pokemonImage.getFitHeight() / 2;
        double maxRadius = Math.max(pokemonImage.getFitWidth(), pokemonImage.getFitHeight()) / 2 + 10; // Slightly outside the pokemon

        // Create the dodge movement animation for the Pokémon
        TranslateTransition dodgeAnimation = new TranslateTransition(Duration.seconds(ANIMATION_DURATION * 0.4), pokemonImage);

        // Decide randomly which direction to dodge (left/right and slightly up/down)
        boolean dodgeRight = RANDOM.nextBoolean();
        double dodgeDistance = pokemonImage.getFitWidth() * 0.3; // 30% of width
        double dodgeX = dodgeRight ? dodgeDistance : -dodgeDistance;
        double dodgeY = RANDOM.nextDouble() * dodgeDistance * 0.5 - (dodgeDistance * 0.25); // slight vertical movement

        // Quick dodge to the side and back
        dodgeAnimation.setByX(dodgeX);
        dodgeAnimation.setByY(dodgeY);
        dodgeAnimation.setCycleCount(2);
        dodgeAnimation.setAutoReverse(true);
        dodgeAnimation.setInterpolator(Interpolator.SPLINE(0.5, 0.1, 0.1, 0.5)); // Custom curve for natural movement

        for (Circle particle : particles) {
            // Assign a random starting angle for each particle (in radians)
            double startAngle = RANDOM.nextDouble() * 2 * Math.PI;
            // Random rotation direction (clockwise or counter-clockwise)
            int direction = RANDOM.nextBoolean() ? 1 : -1;
            // Random orbital speed
            double speed = 1.0 + RANDOM.nextDouble() * 0.5;

            // Assign a random radius value between 40% and 100% of the max radius
            // This creates variance so some particles are closer to the center
            double particleRadius = maxRadius * (0.4 + RANDOM.nextDouble() * 0.6);

            Timeline timeline = new Timeline();
            KeyFrame[] keyFrames = new KeyFrame[60];

            for (int i = 0; i < keyFrames.length; i++) {
                final int index = i;
                keyFrames[i] = new KeyFrame(
                        Duration.seconds(ANIMATION_DURATION * i / keyFrames.length),
                        event -> {
                            double progress = (double) index / keyFrames.length;
                            // Calculate current angle based on progress, starting angle, and direction
                            double angle = startAngle + direction * progress * 2 * Math.PI * speed;

                            // Calculate new position on the circle with variance in the radius
                            // Add a small sin wave variance to make movement more dynamic
                            double radiusVariance = particleRadius * (1.0 + Math.sin(progress * 6) * 0.1);
                            double newX = centerX + radiusVariance * Math.cos(angle);
                            double newY = centerY + radiusVariance * Math.sin(angle);

                            particle.setCenterX(newX);
                            particle.setCenterY(newY);
                        }
                );
            }

            timeline.getKeyFrames().addAll(keyFrames);

            // Create fade out animation
            FadeTransition fadeTransition = new FadeTransition(Duration.seconds(ANIMATION_DURATION), particle);
            fadeTransition.setFromValue(1.0);
            fadeTransition.setToValue(0.0);

            parallelTransition.getChildren().addAll(timeline, fadeTransition);
        }

        // Add the dodge animation to the parallel transition
        parallelTransition.getChildren().add(dodgeAnimation);

        // Start animation and clean up when done
        parallelTransition.play();
        parallelTransition.setOnFinished(event -> {
            parentPane.getChildren().removeAll(particles);
            // Ensure the Pokémon is back at its original position
            pokemonImage.setTranslateX(0);
            pokemonImage.setTranslateY(0);
        });

        // Add glow effect to Pokemon
        DropShadow glow = new DropShadow();
        glow.setColor(Color.AQUA);
        glow.setWidth(70);
        glow.setHeight(70);
        glow.setRadius(150);
        glow.setSpread(0.5);
        glow.setBlurType(BlurType.GAUSSIAN);

        pokemonImage.setEffect(glow);

        // Remove glow after animation
        Timeline glowRemoval = new Timeline(new KeyFrame(Duration.seconds(ANIMATION_DURATION),
                event -> pokemonImage.setEffect(null)));
        glowRemoval.play();
    }

    /**
     * Plays an orange-red particle animation rising from the Pokémon to simulate fire
     * for the BURN effect. The Pokémon also flickers and glows during the animation.
     *
     * @param pokemonImage The ImageView of the Pokémon being burned.
     * @param parentPane   The parent pane to render the particles on.
     */
    private static void playBurnAnimation(ImageView pokemonImage, Pane parentPane) {
        List<Circle> particles = createParticles(30, Color.ORANGERED, pokemonImage);

        parentPane.getChildren().addAll(particles);

        ParallelTransition parallelTransition = new ParallelTransition();

        for (Circle particle : particles) {
            Timeline timeline = new Timeline();
            double startX = particle.getCenterX();
            double startY = particle.getCenterY();
            double endY = startY - RANDOM.nextDouble() * 80 - 40;

            KeyFrame[] keyFrames = new KeyFrame[60];
            for (int i = 0; i < keyFrames.length; i++) {
                final int index = i;
                keyFrames[i] = new KeyFrame(
                        Duration.seconds(ANIMATION_DURATION * i / keyFrames.length),
                        event -> {
                            double progress = (double) index / keyFrames.length;
                            double xOffset = Math.sin(progress * 3 * Math.PI) * 8;
                            particle.setCenterX(startX + xOffset);
                            particle.setCenterY(startY - (startY - endY) * progress);

                            // Adjust color from orange to red
                            double hue = 15 + (progress * 10); // Shift from orange toward red
                            particle.setFill(Color.hsb(hue, 1.0, 1.0, 1.0 - (progress * 0.5)));
                        }
                );
            }

            timeline.getKeyFrames().addAll(keyFrames);

            // Create fade out animation
            FadeTransition fadeTransition = new FadeTransition(Duration.seconds(ANIMATION_DURATION), particle);
            fadeTransition.setFromValue(1.0);
            fadeTransition.setToValue(0.0);

            parallelTransition.getChildren().addAll(timeline, fadeTransition);
        }

        // Start animation and clean up when done
        parallelTransition.play();
        parallelTransition.setOnFinished(event -> parentPane.getChildren().removeAll(particles));


        DropShadow glow = new DropShadow();
        glow.setColor(Color.ORANGERED);
        glow.setWidth(70);
        glow.setHeight(70);
        glow.setRadius(150);
        glow.setSpread(0.5);
        glow.setBlurType(BlurType.GAUSSIAN);

        pokemonImage.setEffect(glow);

        // Flicker effect
        Timeline flickerTimeline = new Timeline();
        for (int i = 0; i < 4; i++) {
            KeyFrame keyFrame1 = new KeyFrame(Duration.seconds(i * 0.5), e -> pokemonImage.setOpacity(0.7));
            KeyFrame keyFrame2 = new KeyFrame(Duration.seconds(i * 0.5 + 0.25), e -> pokemonImage.setOpacity(1.0));
            flickerTimeline.getKeyFrames().addAll(keyFrame1, keyFrame2);
        }

        flickerTimeline.play();
        flickerTimeline.setOnFinished(event -> pokemonImage.setEffect(null));
    }

    /**
     * Plays a green particle animation swirling toward the Pokémon to indicate
     * a healing or DRAIN effect. The particles spiral inward, and the Pokémon glows green.
     *
     * @param pokemonImage The ImageView of the Pokémon healing.
     * @param parentPane   The parent pane to render the particles on.
     */
    private static void playDrainAnimation(ImageView pokemonImage, Pane parentPane) {
        // Create green particles for healing
        List<Circle> particles = createParticles(25, Color.GREENYELLOW, pokemonImage);

        // Add particles to parent pane
        parentPane.getChildren().addAll(particles);

        // Create animation for each particle
        ParallelTransition parallelTransition = new ParallelTransition();

        for (Circle particle : particles) {
            // Create spiral inward movement
            Timeline timeline = new Timeline();
            double centerX = pokemonImage.getLayoutX() + pokemonImage.getFitWidth() / 2;
            double centerY = pokemonImage.getLayoutY() + pokemonImage.getFitHeight() / 2;
            double startX = particle.getCenterX();
            double startY = particle.getCenterY();
            double angle = Math.atan2(startY - centerY, startX - centerX);
            double radius = Math.sqrt(Math.pow(startX - centerX, 2) + Math.pow(startY - centerY, 2));

            KeyFrame[] keyFrames = new KeyFrame[60];
            for (int i = 0; i < keyFrames.length; i++) {
                final int index = i;
                keyFrames[i] = new KeyFrame(
                        Duration.seconds(ANIMATION_DURATION * i / keyFrames.length),
                        event -> {
                            double progress = (double) index / keyFrames.length;
                            double currentRadius = radius * (1.0 - progress);
                            double currentAngle = angle + (progress * Math.PI * 4);

                            double newX = centerX + Math.cos(currentAngle) * currentRadius;
                            double newY = centerY + Math.sin(currentAngle) * currentRadius;

                            particle.setCenterX(newX);
                            particle.setCenterY(newY);

                            // Adjust color from yellow to green
                            particle.setFill(Color.rgb(
                                    (int)(100 - (progress * 100)),
                                    (int)(255),
                                    (int)(progress * 100)));
                        }
                );
            }

            timeline.getKeyFrames().addAll(keyFrames);

            parallelTransition.getChildren().add(timeline);
        }

        // Start animation and clean up when done
        parallelTransition.play();
        parallelTransition.setOnFinished(event -> parentPane.getChildren().removeAll(particles));

        // Add green glow to Pokemon
        DropShadow glow = new DropShadow();
        glow.setColor(Color.LIMEGREEN);
        glow.setWidth(70);
        glow.setHeight(70);
        glow.setRadius(150);
        glow.setSpread(0.5);
        glow.setBlurType(BlurType.GAUSSIAN);

        pokemonImage.setEffect(glow);

        // Remove glow after animation
        Timeline glowRemoval = new Timeline(new KeyFrame(Duration.seconds(ANIMATION_DURATION),
                event -> pokemonImage.setEffect(null)));
        glowRemoval.play();
    }

    /**
     * Plays a yellow zigzag particle animation around the Pokémon to simulate electric shocks,
     * and the Pokémon slightly shakes. Represents the PARALYZE effect.
     *
     * @param pokemonImage The ImageView of the paralyzed Pokémon.
     * @param parentPane   The parent pane to render the particles on.
     */
    private static void playParalyzeAnimation(ImageView pokemonImage, Pane parentPane) {
        // Create electric particles
        List<Circle> particles = createParticles(30, Color.YELLOW, pokemonImage);

        // Add particles to parent pane
        parentPane.getChildren().addAll(particles);

        // Create animation for each particle
        ParallelTransition parallelTransition = new ParallelTransition();

        for (Circle particle : particles) {
            // Create zigzag movement
            Timeline timeline = new Timeline();
            double startX = particle.getCenterX();
            double startY = particle.getCenterY();

            KeyFrame[] keyFrames = new KeyFrame[60];
            for (int i = 0; i < keyFrames.length; i++) {
                final int index = i;
                keyFrames[i] = new KeyFrame(
                        Duration.seconds(ANIMATION_DURATION * i / keyFrames.length),
                        event -> {
                            double progress = (double) index / keyFrames.length;
                            // Zigzag effect
                            double xOffset = Math.sin(progress * 20) * 15;
                            double yOffset = Math.cos(progress * 15) * 15;

                            particle.setCenterX(startX + xOffset);
                            particle.setCenterY(startY + yOffset);

                            // Flicker effect
                            particle.setOpacity(Math.abs(Math.sin(progress * 30)));
                        }
                );
            }

            timeline.getKeyFrames().addAll(keyFrames);
            parallelTransition.getChildren().add(timeline);
        }

        // Start animation and clean up when done
        parallelTransition.play();
        parallelTransition.setOnFinished(event -> parentPane.getChildren().removeAll(particles));

        DropShadow glow = new DropShadow();
        glow.setColor(Color.YELLOW);
        glow.setWidth(70);
        glow.setHeight(70);
        glow.setRadius(150);
        glow.setSpread(0.5);
        glow.setBlurType(BlurType.GAUSSIAN);

        pokemonImage.setEffect(glow);

        // Shaking animation for paralysis
        Timeline shakeTimeline = new Timeline();
        double originalX = pokemonImage.getLayoutX();

        for (int i = 0; i < 10; i++) {
            KeyFrame keyFrame1 = new KeyFrame(Duration.seconds(i * 0.25), event -> {
                pokemonImage.setLayoutX(originalX + (RANDOM.nextDouble() * 10 - 5));
                pokemonImage.setEffect(glow);
            });
            KeyFrame keyFrame2 = new KeyFrame(Duration.seconds(i * 0.25 + 0.125), event -> {
                pokemonImage.setLayoutX(originalX);
                pokemonImage.setEffect(null);
            });
            shakeTimeline.getKeyFrames().addAll(keyFrame1, keyFrame2);
        }

        shakeTimeline.play();
        shakeTimeline.setOnFinished(event -> {
            pokemonImage.setLayoutX(originalX);
            pokemonImage.setEffect(null);
        });
    }

    /**
     * Plays a red glowing effect and a flash animation on the Pokémon
     * to indicate a critical hit. Also shows a "CRIT!" text rising above the Pokémon.
     *
     * @param pokemonImage The ImageView of the Pokémon taking a critical hit.
     * @param parentPane   The parent pane to render the visual effect.
     */
    private static void playCritAnimation(ImageView pokemonImage, Pane parentPane) {
        // Create a brighter red flash effect for critical hit
        DropShadow glow = new DropShadow();
        glow.setColor(Color.RED);
        glow.setWidth(70);
        glow.setHeight(70);
        glow.setRadius(150);
        glow.setSpread(0.5);
        glow.setBlurType(BlurType.GAUSSIAN);

        pokemonImage.setEffect(glow);

        // Create flash animation - more intense
        Timeline flashTimeline = new Timeline();
        flashTimeline.getKeyFrames().addAll(
                new KeyFrame(Duration.ZERO, event -> pokemonImage.setEffect(glow)),
                new KeyFrame(Duration.seconds(0.1), event -> pokemonImage.setEffect(null)),
                new KeyFrame(Duration.seconds(0.2), event -> pokemonImage.setEffect(glow)),
                new KeyFrame(Duration.seconds(0.3), event -> pokemonImage.setEffect(null))
        );

        // Play flash animation twice
        flashTimeline.setCycleCount(2);
        flashTimeline.play();

        // Get pokemon center coordinates
        double centerX = pokemonImage.getLayoutX() + pokemonImage.getFitWidth() / 2;
        double centerY = pokemonImage.getLayoutY() + pokemonImage.getFitHeight() / 2;

        // Create "CRIT" text
        Text critText = new Text("CRIT!");
        critText.setFont(Font.font("Impact", FontWeight.BOLD, 36));
        critText.setFill(Color.RED);
        critText.setStroke(Color.WHITE);
        critText.setStrokeWidth(2);

        // Position the text above the Pokemon
        critText.setX(centerX - 50);
        critText.setY(centerY - 50);
        critText.setOpacity(0);

        // Add the text to the pane
        parentPane.getChildren().add(critText);

        // Animate the text
        Timeline textAnimation = new Timeline();
        textAnimation.getKeyFrames().addAll(
                new KeyFrame(Duration.ZERO, new KeyValue(critText.opacityProperty(), 0)),
                new KeyFrame(Duration.seconds(0.2), new KeyValue(critText.opacityProperty(), 1)),
                new KeyFrame(Duration.seconds(0.4), new KeyValue(critText.scaleXProperty(), 1.5)),
                new KeyFrame(Duration.seconds(0.4), new KeyValue(critText.scaleYProperty(), 1.5)),
                new KeyFrame(Duration.seconds(0.8), new KeyValue(critText.opacityProperty(), 0))
        );
        textAnimation.play();

        // Create cross-shaped slash effect
        createCrossSlash(parentPane, centerX, centerY);

        // Create impact particles - fewer but larger
        List<Circle> particles = new ArrayList<>();

        for (int i = 0; i < 12; i++) {
            Circle particle = new Circle();
            particle.setRadius(RANDOM.nextDouble() * 6 + 3);
            particle.setCenterX(centerX);
            particle.setCenterY(centerY);

            // Red to yellow gradient for particles (more "fiery")
            double hue = RANDOM.nextDouble() * 60; // Red to yellow range
            double brightness = RANDOM.nextDouble() * 0.3 + 0.7; // Very bright
            particle.setFill(Color.hsb(hue, 1.0, brightness));

            particles.add(particle);
        }

        parentPane.getChildren().addAll(particles);

        // Animate particles outward with more speed
        ParallelTransition particleAnimation = new ParallelTransition();

        for (Circle particle : particles) {
            // Random direction for each particle
            double angle = RANDOM.nextDouble() * Math.PI * 2;
            double distance = RANDOM.nextDouble() * 150 + 70;
            double endX = centerX + Math.cos(angle) * distance;
            double endY = centerY + Math.sin(angle) * distance;

            Timeline timeline = new Timeline();
            timeline.getKeyFrames().add(new KeyFrame(Duration.seconds(0.6),
                    new KeyValue(particle.centerXProperty(), endX),
                    new KeyValue(particle.centerYProperty(), endY),
                    new KeyValue(particle.opacityProperty(), 0)
            ));

            particleAnimation.getChildren().add(timeline);
        }

        particleAnimation.play();

        // Clean up all elements
        particleAnimation.setOnFinished(event -> {
            parentPane.getChildren().removeAll(particles);
            parentPane.getChildren().remove(critText);
        });
    }

    /**
     * Creates a cross-shaped slash animation effect centered at the specified coordinates.
     * This animation simulates two diagonal slashes forming an "X" shape, with glow and fade-out effects.
     * Typically used for visualizing a slicing or high-damage move in battle.
     *
     * @param parentPane The parent pane where the slashes will be added and animated.
     * @param centerX    The X-coordinate for the center of the cross slash.
     * @param centerY    The Y-coordinate for the center of the cross slash.
     */
    private static void createCrossSlash(Pane parentPane, double centerX, double centerY) {
        // Create diagonal lines for cross effect
        Line slash1 = createSlashLine(centerX, centerY);
        Line slash2 = createSlashLine(centerX, centerY);

        // Add slashes to the pane
        parentPane.getChildren().addAll(slash1, slash2);

        // Animate the slashes
        Timeline slashAnimation = new Timeline();

        // Grow and fade animation
        slashAnimation.getKeyFrames().addAll(
                // Slash 1 animation
                new KeyFrame(Duration.ZERO,
                        new KeyValue(slash1.startXProperty(), centerX),
                        new KeyValue(slash1.startYProperty(), centerY),
                        new KeyValue(slash1.endXProperty(), centerX),
                        new KeyValue(slash1.endYProperty(), centerY),
                        new KeyValue(slash1.opacityProperty(), 0.9),
                        new KeyValue(slash1.strokeWidthProperty(), 3)
                ),
                new KeyFrame(Duration.seconds(ANIMATION_DURATION / 2 - 0.3),
                        new KeyValue(slash1.startXProperty(), centerX - 70),
                        new KeyValue(slash1.startYProperty(), centerY - 70),
                        new KeyValue(slash1.endXProperty(), centerX + 70),
                        new KeyValue(slash1.endYProperty(), centerY + 70),
                        new KeyValue(slash1.opacityProperty(), 0),
                        new KeyValue(slash1.strokeWidthProperty(), 1)
                ),

                // Slash 2 animation (starts slightly after)
                new KeyFrame(Duration.seconds(0.05),
                        new KeyValue(slash2.startXProperty(), centerX),
                        new KeyValue(slash2.startYProperty(), centerY),
                        new KeyValue(slash2.endXProperty(), centerX),
                        new KeyValue(slash2.endYProperty(), centerY),
                        new KeyValue(slash2.opacityProperty(), 0.9),
                        new KeyValue(slash2.strokeWidthProperty(), 3)
                ),
                new KeyFrame(Duration.seconds(ANIMATION_DURATION / 2 - 0.25),
                        new KeyValue(slash2.startXProperty(), centerX - 70),
                        new KeyValue(slash2.startYProperty(), centerY + 70),
                        new KeyValue(slash2.endXProperty(), centerX + 70),
                        new KeyValue(slash2.endYProperty(), centerY - 70),
                        new KeyValue(slash2.opacityProperty(), 0),
                        new KeyValue(slash2.strokeWidthProperty(), 1)
                )
        );

        slashAnimation.play();

        // Remove slashes when animation is done
        slashAnimation.setOnFinished(event -> parentPane.getChildren().removeAll(slash1, slash2));
    }

    /**
     * Creates a glowing diagonal slash line centered at the specified coordinates.
     * The line is initialized with red color and a drop shadow to simulate energy or power.
     * Used by {@link #createCrossSlash} to form each part of the slash animation.
     *
     * @param centerX The X-coordinate for the starting and ending point of the slash line.
     * @param centerY The Y-coordinate for the starting and ending point of the slash line.
     * @return A configured {@link Line} with red glow effect.
     */
    private static Line createSlashLine(double centerX, double centerY) {
        Line slash = new Line();
        slash.setStartX(centerX);
        slash.setStartY(centerY);
        slash.setEndX(centerX);
        slash.setEndY(centerY);

        // Create a white core with red glow effect
        slash.setStroke(Color.RED);
        slash.setStrokeWidth(2);

        // Add glow effect
        DropShadow glow = new DropShadow();
        glow.setColor(Color.RED);
        glow.setWidth(10);
        glow.setHeight(10);
        glow.setRadius(5);
        slash.setEffect(glow);

        return slash;
    }

    /**
     * Creates a list of glowing particles centered around a Pokémon sprite.
     * Each particle is a circle with randomized size, position, and slightly varied color
     * to simulate natural-looking effects such as embers, sparks, or healing particles.
     *
     * @param count        The number of particles to generate.
     * @param baseColor    The base color of the particles; each particle's color is a variation of this.
     * @param pokemonImage The ImageView representing the Pokémon; particles will appear over its area.
     * @return A list of configured {@link Circle} nodes representing particles.
     */
    private static List<Circle> createParticles(int count, Color baseColor, ImageView pokemonImage) {
        List<Circle> particles = new ArrayList<>();

        double minX = pokemonImage.getLayoutX();
        double maxX = pokemonImage.getLayoutX() + pokemonImage.getFitWidth();
        double minY = pokemonImage.getLayoutY();
        double maxY = pokemonImage.getLayoutY() + pokemonImage.getFitHeight();

        for (int i = 0; i < count; i++) {
            Circle particle = new Circle();
            particle.setRadius(RANDOM.nextDouble() * 4 + 2); // Random size

            // Position randomly on the Pokemon
            particle.setCenterX(RANDOM.nextDouble() * (maxX - minX) + minX);
            particle.setCenterY(RANDOM.nextDouble() * (maxY - minY) + minY);

            // Slightly randomize color
            double hue = baseColor.getHue() + (RANDOM.nextDouble() * 20 - 10);
            double saturation = baseColor.getSaturation() * (RANDOM.nextDouble() * 0.2 + 0.8);
            double brightness = baseColor.getBrightness() * (RANDOM.nextDouble() * 0.2 + 0.8);
            particle.setFill(Color.hsb(hue, saturation, brightness, 0.8));

            // Add blur for glow effect
            GaussianBlur blur = new GaussianBlur(2);
            particle.setEffect(blur);

            particles.add(particle);
        }

        return particles;
    }
}